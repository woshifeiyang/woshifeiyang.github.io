"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useCssVars = exports.useCssScopedClasses = exports.useCssModuleClasses = exports.createVueFile = void 0;
const vue_code_gen_1 = require("@volar/vue-code-gen");
const refSugarRanges_1 = require("@volar/vue-code-gen/out/parsers/refSugarRanges");
const scriptRanges_1 = require("@volar/vue-code-gen/out/parsers/scriptRanges");
const scriptSetupRanges_1 = require("@volar/vue-code-gen/out/parsers/scriptSetupRanges");
const compiler_sfc_1 = require("@vue/compiler-sfc");
const reactivity_1 = require("@vue/reactivity");
const sourceMaps_1 = require("./utils/sourceMaps");
const string_1 = require("./utils/string");
const untrack_1 = require("./utils/untrack");
const templateGen = require("@volar/vue-code-gen/out/generators/template");
const parseCssClassNames_1 = require("./utils/parseCssClassNames");
const parseCssVars_1 = require("./utils/parseCssVars");
const file_vue_1 = require("./plugins/file-vue");
const file_md_1 = require("./plugins/file-md");
const vue_template_html_1 = require("./plugins/vue-template-html");
const vue_template_pug_1 = require("./plugins/vue-template-pug");
const vue_sfc_styles_1 = require("./plugins/vue-sfc-styles");
const vue_sfc_customblocks_1 = require("./plugins/vue-sfc-customblocks");
const vue_sfc_scripts_1 = require("./plugins/vue-sfc-scripts");
const vue_sfc_template_1 = require("./plugins/vue-sfc-template");
const vue_typescript_scripts_1 = require("./plugins/vue-typescript-scripts");
const vue_typescript_template_1 = require("./plugins/vue-typescript-template");
const source_map_1 = require("@volar/source-map");
;
function createVueFile(fileName, _content, _version, compilerOptions, ts, tsLs, tsHost) {
    var _a;
    // refs
    const fileContent = (0, reactivity_1.ref)('');
    const version = (0, reactivity_1.ref)('');
    const sfc = (0, reactivity_1.reactive)({
        template: null,
        script: null,
        scriptSetup: null,
        styles: [],
        customBlocks: [],
    }) /* avoid Sfc unwrap in .d.ts by reactive */;
    let templateScriptData = {
        projectVersion: undefined,
        components: [],
        componentItems: [],
    };
    // use
    const compiledVue = (0, reactivity_1.computed)(() => {
        var _a;
        for (const plugin of plugins) {
            const compiled = (_a = plugin.compileFileToVue) === null || _a === void 0 ? void 0 : _a.call(plugin, fileName, fileContent.value);
            if (compiled) {
                return compiled;
            }
        }
        // given dummy result to avoid language server throw
        return {
            vue: '<template></template>',
            mapping: vueRange => vueRange,
        };
    });
    const vueContent = (0, reactivity_1.computed)(() => { var _a; return (_a = compiledVue.value) === null || _a === void 0 ? void 0 : _a.vue; });
    const parsedSfc = (0, reactivity_1.computed)(() => vueContent.value !== undefined ? (0, compiler_sfc_1.parse)(vueContent.value, { sourceMap: false, ignoreEmpty: false }) : undefined);
    const computedHtmlTemplate = (0, reactivity_1.computed)(() => {
        var _a;
        if (sfc.template) {
            for (const plugin of plugins) {
                const compiledHtml = (_a = plugin.compileTemplateToHtml) === null || _a === void 0 ? void 0 : _a.call(plugin, sfc.template.lang, sfc.template.content);
                if (compiledHtml) {
                    return compiledHtml;
                }
                ;
            }
        }
    });
    const templateAstCompiled = (0, reactivity_1.computed)(() => {
        var _a;
        if (computedHtmlTemplate.value) {
            return (0, vue_code_gen_1.compileSFCTemplate)(computedHtmlTemplate.value.html, compilerOptions.experimentalTemplateCompilerOptions, (_a = compilerOptions.target) !== null && _a !== void 0 ? _a : 3);
        }
    });
    const cssModuleClasses = useCssModuleClasses(sfc);
    const cssScopedClasses = useCssScopedClasses(sfc, compilerOptions);
    const templateCodeGens = (0, reactivity_1.computed)(() => {
        var _a, _b, _c, _d;
        if (!computedHtmlTemplate.value)
            return;
        if (!((_a = templateAstCompiled.value) === null || _a === void 0 ? void 0 : _a.ast))
            return;
        return templateGen.generate(ts, (_c = (_b = sfc.template) === null || _b === void 0 ? void 0 : _b.lang) !== null && _c !== void 0 ? _c : 'html', templateAstCompiled.value.ast, (_d = compilerOptions.target) !== null && _d !== void 0 ? _d : 3, compilerOptions.experimentalRuntimeMode, !!compilerOptions.experimentalAllowTypeNarrowingInInlineHandlers, !!sfc.scriptSetup, Object.values(cssScopedClasses.value).map(map => Object.keys(map)).flat(), computedHtmlTemplate.value.mapping, {
            getEmitCompletion: string_1.SearchTexts.EmitCompletion,
            getPropsCompletion: string_1.SearchTexts.PropsCompletion,
        });
    });
    const cssVars = useCssVars(sfc);
    const cssVarTexts = (0, reactivity_1.computed)(() => {
        const result = [];
        for (const { style, ranges } of cssVars.value) {
            for (const range of ranges) {
                result.push(style.content.substring(range.start, range.end));
            }
        }
        return result;
    });
    const scriptAst = (0, reactivity_1.computed)(() => {
        if (sfc.script) {
            return ts.createSourceFile(fileName + '.' + sfc.script.lang, sfc.script.content, ts.ScriptTarget.Latest);
        }
    });
    const scriptSetupAst = (0, reactivity_1.computed)(() => {
        if (sfc.scriptSetup) {
            return ts.createSourceFile(fileName + '.' + sfc.scriptSetup.lang, sfc.scriptSetup.content, ts.ScriptTarget.Latest);
        }
    });
    const scriptRanges = (0, reactivity_1.computed)(() => scriptAst.value
        ? (0, scriptRanges_1.parseScriptRanges)(ts, scriptAst.value, !!sfc.scriptSetup, false, false)
        : undefined);
    const scriptSetupRanges = (0, reactivity_1.computed)(() => scriptSetupAst.value
        ? (0, scriptSetupRanges_1.parseScriptSetupRanges)(ts, scriptSetupAst.value)
        : undefined);
    const scriptLang = (0, reactivity_1.computed)(() => {
        return !sfc.script && !sfc.scriptSetup ? 'ts'
            : sfc.scriptSetup && sfc.scriptSetup.lang !== 'js' ? sfc.scriptSetup.lang
                : sfc.script && sfc.script.lang !== 'js' ? sfc.script.lang
                    : 'js';
    });
    const sfcRefSugarRanges = (0, reactivity_1.computed)(() => (scriptSetupAst.value ? {
        refs: (0, refSugarRanges_1.parseRefSugarDeclarationRanges)(ts, scriptSetupAst.value, ['$ref', '$computed', '$shallowRef', '$fromRefs']),
        raws: (0, refSugarRanges_1.parseRefSugarCallRanges)(ts, scriptSetupAst.value, ['$raw', '$fromRefs']),
    } : undefined));
    const plugins = [
        (0, file_vue_1.default)(),
        (0, file_md_1.default)(),
        (0, vue_template_html_1.default)(),
        (0, vue_template_pug_1.default)(),
        (0, vue_sfc_styles_1.default)(),
        (0, vue_sfc_customblocks_1.default)(),
        (0, vue_sfc_scripts_1.default)(),
        (0, vue_sfc_template_1.default)(),
        (0, vue_typescript_scripts_1.default)(scriptLang, scriptRanges, scriptSetupRanges, templateCodeGens, compilerOptions, cssVarTexts),
        (0, vue_typescript_template_1.default)(ts, cssModuleClasses, cssScopedClasses, templateCodeGens, cssVars, scriptSetupRanges, scriptLang, compilerOptions, !!compilerOptions.experimentalDisableTemplateSupport || ((_a = tsHost === null || tsHost === void 0 ? void 0 : tsHost.getCompilationSettings().jsx) !== null && _a !== void 0 ? _a : ts.JsxEmit.Preserve) !== ts.JsxEmit.Preserve),
    ];
    // computeds
    const pluginEmbeddeds = plugins.map(plugin => {
        if (plugin.getEmbeddedFilesCount && plugin.getEmbeddedFile) {
            const embeddedsCount = (0, reactivity_1.computed)(() => plugin.getEmbeddedFilesCount(sfc));
            const embeddeds = (0, reactivity_1.computed)(() => {
                const computeds = [];
                for (let i = 0; i < embeddedsCount.value; i++) {
                    const _i = i;
                    const raw = (0, reactivity_1.computed)(() => plugin.getEmbeddedFile(fileName, sfc, _i));
                    const transformed = (0, reactivity_1.computed)(() => {
                        var _a;
                        if (!raw.value)
                            return;
                        const sourceMap = raw.value.sourceMap;
                        const newMappings = [];
                        for (const mapping of sourceMap.mappings) {
                            const vueRange = embeddedRangeToVueRange(mapping.data, mapping.sourceRange);
                            const fileRange = compiledVue.value.mapping(vueRange);
                            if (fileRange) {
                                let additional;
                                if (mapping.additional) {
                                    additional = [];
                                    for (const add of mapping.additional) {
                                        const addVueRange = embeddedRangeToVueRange(mapping.data, add.sourceRange);
                                        const addFileRange = compiledVue.value.mapping(addVueRange);
                                        if (addFileRange) {
                                            additional.push(Object.assign(Object.assign({}, add), { sourceRange: addFileRange }));
                                        }
                                    }
                                }
                                newMappings.push(Object.assign(Object.assign({}, mapping), { sourceRange: fileRange, additional }));
                            }
                            else if (((_a = compiledVue.value) === null || _a === void 0 ? void 0 : _a.sourceMap) && mapping.mode === source_map_1.Mode.Offset) {
                                // fix markdown template mapping failed
                                const inRangeMappings = compiledVue.value.sourceMap.mappings.filter(mapping => mapping.mappedRange.start >= vueRange.start && mapping.mappedRange.end <= vueRange.end);
                                for (const inRangeMapping of inRangeMappings) {
                                    const _vueRange = inRangeMapping.mappedRange;
                                    const embedded = vueRangeToEmbeddedRange(mapping.data, _vueRange);
                                    newMappings.push(Object.assign(Object.assign({}, mapping), { sourceRange: inRangeMapping.sourceRange, mappedRange: embedded }));
                                }
                            }
                        }
                        const newSourceMap = new sourceMaps_1.EmbeddedFileSourceMap(newMappings);
                        const newEmbedded = Object.assign(Object.assign({}, raw.value), { sourceMap: newSourceMap });
                        return newEmbedded;
                    });
                    computeds.push(transformed);
                }
                return computeds;
            });
            return embeddeds;
        }
    }).filter(notEmpty);
    const embeddedVue = (0, reactivity_1.computed)(() => {
        var _a;
        if (!fileName.endsWith('.vue') && ((_a = compiledVue.value) === null || _a === void 0 ? void 0 : _a.sourceMap)) {
            const newSourceMap = new sourceMaps_1.EmbeddedFileSourceMap();
            for (const mapping of compiledVue.value.sourceMap.mappings) {
                newSourceMap.mappings.push(Object.assign(Object.assign({}, mapping), { data: {
                        vueTag: undefined,
                        capabilities: {
                            basic: true,
                            references: true,
                            definitions: true,
                            diagnostic: true,
                            rename: true,
                            completion: true,
                            semanticTokens: true,
                            referencesCodeLens: false,
                            displayWithLink: false,
                        },
                    } }));
            }
            const embeddedFile = {
                fileName: fileName + '.vue',
                lang: 'vue',
                content: compiledVue.value.vue,
                capabilities: {
                    diagnostics: true,
                    foldingRanges: false,
                    formatting: false,
                    documentSymbol: false,
                    codeActions: true,
                    inlayHints: true,
                },
                isTsHostFile: false,
            };
            const embedded = {
                file: embeddedFile,
                sourceMap: newSourceMap,
            };
            return embedded;
        }
    });
    const allEmbeddeds = (0, reactivity_1.computed)(() => {
        const all = [];
        if (embeddedVue.value) {
            all.push(embeddedVue.value);
        }
        for (const getEmbeddeds of pluginEmbeddeds) {
            for (const embedded of getEmbeddeds.value) {
                if (embedded.value) {
                    if (embeddedVue.value && !embedded.value.parentFileName) {
                        all.push(Object.assign(Object.assign({}, embedded.value), { parentFileName: embeddedVue.value.file.fileName }));
                    }
                    else {
                        all.push(embedded.value);
                    }
                }
            }
        }
        return all;
    });
    const teleports = (0, reactivity_1.computed)(() => {
        const _all = [];
        for (const embedded of allEmbeddeds.value) {
            if (embedded.teleport) {
                _all.push({
                    file: embedded.file,
                    teleport: embedded.teleport,
                });
            }
        }
        return _all;
    });
    const embeddeds = (0, reactivity_1.computed)(() => {
        const embeddeds = [];
        let remain = [...allEmbeddeds.value];
        while (remain.length) {
            const beforeLength = remain.length;
            consumeRemain();
            if (beforeLength === remain.length) {
                break;
            }
        }
        for (const e of remain) {
            embeddeds.push({
                self: e,
                embeddeds: [],
            });
            // 	throw 'Unable to resolve embeddeds: ' + remain[0].parentFileName + ' -> ' + remain[0].file.fileName;
        }
        return embeddeds;
        function consumeRemain() {
            for (let i = remain.length - 1; i >= 0; i--) {
                const embedded = remain[i];
                if (!embedded.parentFileName) {
                    embeddeds.push({
                        self: embedded,
                        embeddeds: [],
                    });
                    remain.splice(i, 1);
                }
                else {
                    const parent = findParentStructure(embedded.parentFileName, embeddeds);
                    if (parent) {
                        parent.embeddeds.push({
                            self: embedded,
                            inheritParentIndent: true,
                            embeddeds: [],
                        });
                        remain.splice(i, 1);
                    }
                }
            }
        }
        function findParentStructure(fileName, strus) {
            var _a;
            for (const stru of strus) {
                if (((_a = stru.self) === null || _a === void 0 ? void 0 : _a.file.fileName) === fileName) {
                    return stru;
                }
                let _stru = findParentStructure(fileName, stru.embeddeds);
                if (_stru) {
                    return _stru;
                }
            }
        }
    });
    update(_content, _version);
    return {
        fileName,
        getContent: (0, untrack_1.untrack)(() => fileContent.value),
        getCompiledVue: (0, untrack_1.untrack)(() => compiledVue.value),
        getSfcTemplateLanguageCompiled: (0, untrack_1.untrack)(() => computedHtmlTemplate.value),
        getSfcVueTemplateCompiled: (0, untrack_1.untrack)(() => templateAstCompiled.value),
        getVersion: (0, untrack_1.untrack)(() => version.value),
        update: (0, untrack_1.untrack)(update),
        getTemplateData: (0, untrack_1.untrack)(getTemplateData),
        getScriptFileName: (0, untrack_1.untrack)(() => fileName + '.' + scriptLang.value),
        getDescriptor: (0, untrack_1.untrack)(() => (0, reactivity_1.unref)(sfc)),
        getScriptAst: (0, untrack_1.untrack)(() => scriptAst.value),
        getScriptSetupAst: (0, untrack_1.untrack)(() => scriptSetupAst.value),
        getSfcRefSugarRanges: (0, untrack_1.untrack)(() => sfcRefSugarRanges.value),
        getEmbeddeds: (0, untrack_1.untrack)(() => embeddeds.value),
        getAllEmbeddeds: (0, untrack_1.untrack)(() => allEmbeddeds.value),
        getScriptSetupRanges: (0, untrack_1.untrack)(() => scriptSetupRanges.value),
        isJsxMissing: () => { var _a; return !compilerOptions.experimentalDisableTemplateSupport && ((_a = tsHost === null || tsHost === void 0 ? void 0 : tsHost.getCompilationSettings().jsx) !== null && _a !== void 0 ? _a : ts.JsxEmit.Preserve) !== ts.JsxEmit.Preserve; },
        refs: {
            content: fileContent,
            allEmbeddeds,
            teleports,
        },
    };
    function embeddedRangeToVueRange(data, range) {
        var _a;
        if (vueContent.value === undefined)
            throw 'vueContent.value === undefined';
        if (data.vueTag === 'scriptSrc') {
            if (!((_a = sfc.script) === null || _a === void 0 ? void 0 : _a.src))
                throw '!sfc.script?.src';
            const vueStart = vueContent.value.substring(0, sfc.script.startTagEnd).lastIndexOf(sfc.script.src);
            const vueEnd = vueStart + sfc.script.src.length;
            return {
                start: vueStart - 1,
                end: vueEnd + 1,
            };
        }
        else if (data.vueTag === 'script') {
            if (!sfc.script)
                throw '!sfc.script';
            return {
                start: range.start + sfc.script.startTagEnd,
                end: range.end + sfc.script.startTagEnd,
            };
        }
        else if (data.vueTag === 'scriptSetup') {
            if (!sfc.scriptSetup)
                throw '!sfc.scriptSetup';
            return {
                start: range.start + sfc.scriptSetup.startTagEnd,
                end: range.end + sfc.scriptSetup.startTagEnd,
            };
        }
        else if (data.vueTag === 'template') {
            if (!sfc.template)
                throw '!sfc.template';
            return {
                start: range.start + sfc.template.startTagEnd,
                end: range.end + sfc.template.startTagEnd,
            };
        }
        else if (data.vueTag === 'style') {
            if (data.vueTagIndex === undefined)
                throw 'data.vueTagIndex === undefined';
            return {
                start: range.start + sfc.styles[data.vueTagIndex].startTagEnd,
                end: range.end + sfc.styles[data.vueTagIndex].startTagEnd,
            };
        }
        else if (data.vueTag === 'customBlock') {
            if (data.vueTagIndex === undefined)
                throw 'data.vueTagIndex === undefined';
            return {
                start: range.start + sfc.customBlocks[data.vueTagIndex].startTagEnd,
                end: range.end + sfc.customBlocks[data.vueTagIndex].startTagEnd,
            };
        }
        return range;
    }
    function vueRangeToEmbeddedRange(data, range) {
        if (vueContent.value === undefined)
            throw 'vueContent.value === undefined';
        if (data.vueTag === 'script') {
            if (!sfc.script)
                throw '!sfc.script';
            return {
                start: range.start - sfc.script.startTagEnd,
                end: range.end - sfc.script.startTagEnd,
            };
        }
        else if (data.vueTag === 'scriptSetup') {
            if (!sfc.scriptSetup)
                throw '!sfc.scriptSetup';
            return {
                start: range.start - sfc.scriptSetup.startTagEnd,
                end: range.end - sfc.scriptSetup.startTagEnd,
            };
        }
        else if (data.vueTag === 'template') {
            if (!sfc.template)
                throw '!sfc.template';
            return {
                start: range.start - sfc.template.startTagEnd,
                end: range.end - sfc.template.startTagEnd,
            };
        }
        else if (data.vueTag === 'style') {
            if (data.vueTagIndex === undefined)
                throw 'data.vueTagIndex === undefined';
            return {
                start: range.start - sfc.styles[data.vueTagIndex].startTagEnd,
                end: range.end - sfc.styles[data.vueTagIndex].startTagEnd,
            };
        }
        else if (data.vueTag === 'customBlock') {
            if (data.vueTagIndex === undefined)
                throw 'data.vueTagIndex === undefined';
            return {
                start: range.start - sfc.customBlocks[data.vueTagIndex].startTagEnd,
                end: range.end - sfc.customBlocks[data.vueTagIndex].startTagEnd,
            };
        }
        return range;
    }
    function update(newContent, newVersion) {
        const oldScripts = {};
        for (const embedded of allEmbeddeds.value) {
            if (embedded.file.isTsHostFile) {
                oldScripts[embedded.file.fileName] = embedded.file.content;
            }
        }
        fileContent.value = newContent;
        version.value = newVersion;
        // TODO: wait for https://github.com/vuejs/core/pull/5912
        if (parsedSfc.value) {
            updateTemplate(parsedSfc.value.descriptor.template);
            updateScript(parsedSfc.value.descriptor.script);
            updateScriptSetup(parsedSfc.value.descriptor.scriptSetup);
            updateStyles(parsedSfc.value.descriptor.styles);
            updateCustomBlocks(parsedSfc.value.descriptor.customBlocks);
        }
        const newScripts = {};
        for (const embedded of allEmbeddeds.value) {
            if (embedded.file.isTsHostFile) {
                newScripts[embedded.file.fileName] = embedded.file.content;
            }
        }
        return {
            scriptUpdated: Object.keys(oldScripts).length !== Object.keys(newScripts).length
                || Object.keys(oldScripts).some(fileName => oldScripts[fileName] !== newScripts[fileName]),
        };
        function updateTemplate(block) {
            var _a;
            const newData = block ? {
                tag: 'template',
                start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                startTagEnd: block.loc.start.offset,
                endTagStart: block.loc.end.offset,
                content: block.content,
                lang: (_a = block.lang) !== null && _a !== void 0 ? _a : 'html',
            } : null;
            if (sfc.template && newData) {
                updateBlock(sfc.template, newData);
            }
            else {
                sfc.template = newData;
            }
        }
        function updateScript(block) {
            var _a;
            const newData = block ? {
                tag: 'script',
                start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                startTagEnd: block.loc.start.offset,
                endTagStart: block.loc.end.offset,
                content: block.content,
                lang: getValidScriptSyntax((_a = block.lang) !== null && _a !== void 0 ? _a : 'js'),
                src: block.src,
            } : null;
            if (sfc.script && newData) {
                updateBlock(sfc.script, newData);
            }
            else {
                sfc.script = newData;
            }
        }
        function updateScriptSetup(block) {
            var _a;
            const newData = block ? {
                tag: 'scriptSetup',
                start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                startTagEnd: block.loc.start.offset,
                endTagStart: block.loc.end.offset,
                content: block.content,
                lang: getValidScriptSyntax((_a = block.lang) !== null && _a !== void 0 ? _a : 'js'),
            } : null;
            if (sfc.scriptSetup && newData) {
                updateBlock(sfc.scriptSetup, newData);
            }
            else {
                sfc.scriptSetup = newData;
            }
        }
        function updateStyles(blocks) {
            var _a;
            for (let i = 0; i < blocks.length; i++) {
                const block = blocks[i];
                const newData = {
                    tag: 'style',
                    start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                    end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                    startTagEnd: block.loc.start.offset,
                    endTagStart: block.loc.end.offset,
                    content: block.content,
                    lang: (_a = block.lang) !== null && _a !== void 0 ? _a : 'css',
                    module: typeof block.module === 'string' ? block.module : block.module ? '$style' : undefined,
                    scoped: !!block.scoped,
                };
                if (sfc.styles.length > i) {
                    updateBlock(sfc.styles[i], newData);
                }
                else {
                    sfc.styles.push(newData);
                }
            }
            while (sfc.styles.length > blocks.length) {
                sfc.styles.pop();
            }
        }
        function updateCustomBlocks(blocks) {
            var _a;
            for (let i = 0; i < blocks.length; i++) {
                const block = blocks[i];
                const newData = {
                    tag: 'customBlock',
                    start: newContent.substring(0, block.loc.start.offset).lastIndexOf('<'),
                    end: block.loc.end.offset + newContent.substring(block.loc.end.offset).indexOf('>') + 1,
                    startTagEnd: block.loc.start.offset,
                    endTagStart: block.loc.end.offset,
                    content: block.content,
                    lang: (_a = block.lang) !== null && _a !== void 0 ? _a : 'txt',
                    type: block.type,
                };
                if (sfc.customBlocks.length > i) {
                    updateBlock(sfc.customBlocks[i], newData);
                }
                else {
                    sfc.customBlocks.push(newData);
                }
            }
            while (sfc.customBlocks.length > blocks.length) {
                sfc.customBlocks.pop();
            }
        }
        function updateBlock(oldBlock, newBlock) {
            for (let key in newBlock) {
                oldBlock[key] = newBlock[key];
            }
        }
    }
    function getTemplateData() {
        var _a, _b, _c, _d, _e;
        if (!tsHost)
            return templateScriptData;
        if (!tsLs)
            return templateScriptData;
        const newVersion = (_a = tsHost.getProjectVersion) === null || _a === void 0 ? void 0 : _a.call(tsHost);
        if (templateScriptData.projectVersion === newVersion) {
            return templateScriptData;
        }
        templateScriptData.projectVersion = newVersion;
        const options = {
            includeCompletionsWithInsertText: true, // if missing, { 'aaa-bbb': any, ccc: any } type only has result ['ccc']
        };
        const file = (_b = allEmbeddeds.value.find(e => e.file.fileName.indexOf('.__VLS_template.') >= 0)) === null || _b === void 0 ? void 0 : _b.file;
        const hasFile = file &&
            file.content.indexOf(string_1.SearchTexts.Components) >= 0 &&
            // getSourceFile return undefined for lang=js with allowJs=false;
            !!((_c = tsLs.getProgram()) === null || _c === void 0 ? void 0 : _c.getSourceFile(file.fileName));
        let components = hasFile ? (_e = (_d = tsLs.getCompletionsAtPosition(file.fileName, file.content.indexOf(string_1.SearchTexts.Components), options)) === null || _d === void 0 ? void 0 : _d.entries.filter(entry => entry.kind !== ts.ScriptElementKind.warning)) !== null && _e !== void 0 ? _e : [] : [];
        components = components.filter(entry => {
            return entry.name.indexOf('$') === -1 && !entry.name.startsWith('_');
        });
        const componentNames = components.map(entry => entry.name);
        templateScriptData = {
            projectVersion: newVersion,
            components: componentNames,
            componentItems: components,
        };
        return templateScriptData;
    }
}
exports.createVueFile = createVueFile;
function useCssModuleClasses(sfc) {
    return (0, reactivity_1.computed)(() => {
        const result = [];
        for (let i = 0; i < sfc.styles.length; i++) {
            const style = sfc.styles[i];
            if (style.module) {
                result.push({
                    style: style,
                    index: i,
                    classNameRanges: [...(0, parseCssClassNames_1.parseCssClassNames)(style.content)],
                });
            }
        }
        return result;
    });
}
exports.useCssModuleClasses = useCssModuleClasses;
function useCssScopedClasses(sfc, compilerOptions) {
    return (0, reactivity_1.computed)(() => {
        var _a;
        const result = [];
        const setting = (_a = compilerOptions.experimentalResolveStyleCssClasses) !== null && _a !== void 0 ? _a : 'scoped';
        for (let i = 0; i < sfc.styles.length; i++) {
            const style = sfc.styles[i];
            if ((setting === 'scoped' && style.scoped) || setting === 'always') {
                result.push({
                    style: style,
                    index: i,
                    classNameRanges: [...(0, parseCssClassNames_1.parseCssClassNames)(style.content)],
                });
            }
        }
        return result;
    });
}
exports.useCssScopedClasses = useCssScopedClasses;
function useCssVars(sfc) {
    return (0, reactivity_1.computed)(() => {
        const result = [];
        for (let i = 0; i < sfc.styles.length; i++) {
            const style = sfc.styles[i];
            result.push({
                style: style,
                styleIndex: i,
                ranges: [...(0, parseCssVars_1.parseCssVars)(style.content)],
            });
        }
        return result;
    });
}
exports.useCssVars = useCssVars;
const validScriptSyntaxs = ['js', 'jsx', 'ts', 'tsx'];
function getValidScriptSyntax(syntax) {
    if (validScriptSyntaxs.includes(syntax)) {
        return syntax;
    }
    return 'js';
}
function notEmpty(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=vueFile.js.map