"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MarkdownIt = require("markdown-it");
// @ts-expect-error
const MarkdownItAst = require("markdown-it-ast");
const source_map_1 = require("@volar/source-map");
const code_gen_1 = require("@volar/code-gen");
function default_1() {
    return {
        compileFileToVue(fileName, content) {
            if (fileName.endsWith('.md')) {
                let validTemplateBlock;
                let validScriptBlock;
                let validStyleBlock;
                const scriptLines = [];
                const styleLines = [];
                const templateLines = [];
                const tokens = MarkdownIt().parse(content, {});
                const ast = MarkdownItAst.makeAST(tokens);
                for (const node of ast) {
                    // <script> block start tag
                    if (node.nodeType === 'paragraph'
                        && node.children.length
                        && node.children[0].type === 'inline' && (node.children[0].content.startsWith('<script ') || node.children[0].content.startsWith('<script>'))) {
                        breakTemplateBlock();
                        validScriptBlock = node.children[0].map;
                    }
                    // <script> block end tag
                    if (validScriptBlock
                        && node.nodeType === 'paragraph'
                        && node.children.length
                        && node.children[0].type === 'inline' && node.children[0].content.indexOf('</script>') >= 0) {
                        validScriptBlock[1] = node.children[0].map[1];
                        scriptLines.push(validScriptBlock);
                        validScriptBlock = undefined;
                        continue;
                    }
                    if (validScriptBlock) {
                        continue;
                    }
                    // <style> block start tag
                    if (node.nodeType === 'paragraph'
                        && node.children.length
                        && node.children[0].type === 'inline' && (node.children[0].content.startsWith('<style ') || node.children[0].content.startsWith('<style>'))) {
                        breakTemplateBlock();
                        validStyleBlock = node.children[0].map;
                    }
                    // <style> block end tag
                    if (validStyleBlock
                        && node.nodeType === 'paragraph'
                        && node.children.length
                        && node.children[0].type === 'inline' && node.children[0].content.indexOf('</style>') >= 0) {
                        validStyleBlock[1] = node.children[0].map[1];
                        styleLines.push(validStyleBlock);
                        validStyleBlock = undefined;
                        continue;
                    }
                    if (validStyleBlock) {
                        continue;
                    }
                    walkNode(node);
                }
                breakTemplateBlock();
                const codeGen = new code_gen_1.CodeGen();
                const lines = content.split('\n');
                const lineOffsets = [];
                let lineOffset = 0;
                for (const line of lines) {
                    lineOffsets.push(lineOffset);
                    lineOffset += line.length + 1;
                }
                for (const _lines of scriptLines) {
                    const rangeLines = lines.slice(_lines[0], _lines[1]);
                    const rangeCode = rangeLines.join('\n');
                    const start = lineOffsets[_lines[0]];
                    codeGen.addCode(rangeCode, {
                        start: start,
                        end: start + rangeCode.length,
                    }, source_map_1.Mode.Offset, undefined);
                }
                for (const _lines of styleLines) {
                    const rangeLines = lines.slice(_lines[0], _lines[1]);
                    const rangeCode = rangeLines.join('\n');
                    const start = lineOffsets[_lines[0]];
                    codeGen.addCode(rangeCode, {
                        start: start,
                        end: start + rangeCode.length,
                    }, source_map_1.Mode.Offset, undefined);
                }
                if (templateLines.length) {
                    codeGen.addText('\n<template>\n');
                    for (const _lines of templateLines) {
                        const rangeLines = lines.slice(_lines[0], _lines[1]);
                        const rangeCode = rangeLines.join('\n');
                        const start = lineOffsets[_lines[0]];
                        codeGen.addCode(rangeCode
                            // inline code block
                            .replace(/\`([\s\S]*?)\`/g, match => `\`${' '.repeat(match.length - 2)}\``)
                            // # \<script setup>
                            .replace(/\\\<([\s\S]*?)\n/g, match => ' '.repeat(match.length))
                            // markdown line
                            .replace(/\[([\s\S]*?)\]\(([\s\S]*?)\)/g, match => ' '.repeat(match.length)), {
                            start: start,
                            end: start + rangeCode.length,
                        }, source_map_1.Mode.Offset, undefined);
                        codeGen.addText('\n');
                    }
                    codeGen.addText('\n</template>\n');
                }
                const sourceMap = new source_map_1.SourceMapBase(codeGen.getMappings());
                return {
                    vue: codeGen.getText(),
                    mapping: vueRange => { var _a; return (_a = sourceMap.getSourceRange(vueRange.start, vueRange.end)) === null || _a === void 0 ? void 0 : _a[0]; },
                    sourceMap, // for create virtual embedded vue file
                };
                function walkNode(node) {
                    var _a, _b;
                    // ignore ``` block
                    if (node.type === 'fence') {
                        breakTemplateBlock();
                        return false;
                    }
                    let shouldAddRange = true;
                    if (node.children) {
                        for (const child of node.children) {
                            shouldAddRange = shouldAddRange && walkNode(child);
                        }
                    }
                    if (shouldAddRange) {
                        const map = (_a = node.map) !== null && _a !== void 0 ? _a : (_b = node.openNode) === null || _b === void 0 ? void 0 : _b.map;
                        if (map) {
                            addValidTemplateBlockRange(map);
                        }
                    }
                    return true;
                }
                function breakTemplateBlock() {
                    if (validTemplateBlock) {
                        templateLines.push(validTemplateBlock);
                        validTemplateBlock = undefined;
                    }
                }
                function addValidTemplateBlockRange(range) {
                    if (!validTemplateBlock) {
                        validTemplateBlock = [range[0], range[1]];
                    }
                    else {
                        validTemplateBlock[1] = range[1];
                    }
                }
            }
        }
    };
}
exports.default = default_1;
//# sourceMappingURL=file-md.js.map